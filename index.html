<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>히라가나 20칸 연습 도구 - 최적화 버전</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: transparent; 
            font-family: 'Noto Sans KR', sans-serif;
            user-select: none;
        }
        .canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .ui-overlay {
            position: absolute;
            top: 5px;
            width: 95%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: none;
            z-index: 10;
        }
        .status-badge {
            background: rgba(46, 134, 222, 0.95);
            color: white;
            padding: 6px 15px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: bold;
            pointer-events: auto;
            box-shadow: 0 2px 10px rgba(0,0,0,0.15);
            transition: all 0.2s;
        }
        .reset-btn {
            background: rgba(255, 107, 107, 0.95);
            color: white;
            border: none;
            padding: 6px 15px;
            border-radius: 8px;
            cursor: pointer;
            pointer-events: auto;
            font-weight: bold;
            font-size: 13px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.15);
        }
        .reset-btn:hover { background: #ff5252; }
        canvas {
            background-color: transparent; 
            cursor: url('https://cdn-icons-png.flaticon.com/32/595/595582.png'), crosshair;
            touch-action: none;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>

<div class="canvas-container">
    <div class="ui-overlay">
        <div class="status-badge" id="info">연습할 칸에 'あ'를 써보세요</div>
        <button class="reset-btn" onclick="resetAll()">전체 지우기</button>
    </div>
    <canvas id="paintCanvas"></canvas>
</div>

<script>
    const canvas = document.getElementById('paintCanvas');
    const ctx = canvas.getContext('2d');
    const info = document.getElementById('info');
    
    let isDrawing = false;
    let lastPos = null;
    
    // 5열 4행 설정 (총 20칸)
    const gridCols = 5;
    const gridRows = 4;

    // 히라가나 'あ' 가이드 좌표 데이터 (촘촘하게 보강)
    // 이미지상의 'あ' 폰트 궤적을 촘촘한 포인트로 데이터화
    const charTemplate = {
        name: 'A',
        strokes: [
            // 1획: 가로
            { points: [
                {x:0.2, y:0.35}, {x:0.3, y:0.35}, {x:0.4, y:0.35}, 
                {x:0.5, y:0.35}, {x:0.6, y:0.35}, {x:0.7, y:0.35}, {x:0.8, y:0.35}
            ]},
            // 2획: 세로
            { points: [
                {x:0.5, y:0.15}, {x:0.5, y:0.25}, {x:0.5, y:0.35}, 
                {x:0.5, y:0.45}, {x:0.5, y:0.55}, {x:0.5, y:0.65}, {x:0.5, y:0.75}, {x:0.5, y:0.85}
            ]},
            // 3획: 곡선 (이미지 폰트에 맞춰 굴곡 강화)
            { points: [
                {x:0.65, y:0.25}, {x:0.55, y:0.35}, {x:0.45, y:0.45}, {x:0.35, y:0.55},
                {x:0.3, y:0.65}, {x:0.35, y:0.75}, {x:0.45, y:0.82}, {x:0.55, y:0.85},
                {x:0.65, y:0.82}, {x:0.75, y:0.75}, {x:0.82, y:0.65}, {x:0.82, y:0.55},
                {x:0.75, y:0.45}, {x:0.65, y:0.42}, {x:0.55, y:0.45}
            ]}
        ]
    };

    let gridStates = Array.from({ length: 20 }, () => ({
        pointsReached: 0,
        totalPoints: charTemplate.strokes.reduce((acc, s) => acc + s.points.length, 0),
        checkpointStatus: charTemplate.strokes.map(s => s.points.map(() => false)),
        complete: false
    }));

    function resize() {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = canvas.offsetWidth * dpr;
        canvas.height = canvas.offsetHeight * dpr;
        ctx.scale(dpr, dpr);
        
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.lineWidth = 6;
        ctx.strokeStyle = '#1e1e1e';
    }

    window.addEventListener('resize', resize);
    resize();

    function getPos(e) {
        const rect = canvas.getBoundingClientRect();
        const clientX = (e.touches && e.touches[0]) ? e.touches[0].clientX : e.clientX;
        const clientY = (e.touches && e.touches[0]) ? e.touches[0].clientY : e.clientY;
        return {
            x: clientX - rect.left,
            y: clientY - rect.top
        };
    }

    function getGridIndex(x, y) {
        const colWidth = canvas.offsetWidth / gridCols;
        const rowHeight = canvas.offsetHeight / gridRows;
        const col = Math.floor(x / colWidth);
        const row = Math.floor(y / rowHeight);
        if (col < 0 || col >= gridCols || row < 0 || row >= gridRows) return -1;
        return row * gridCols + col;
    }

    function startDrawing(e) {
        const pos = getPos(e);
        const idx = getGridIndex(pos.x, pos.y);
        if (idx === -1) return;
        
        isDrawing = true;
        lastPos = pos;
        ctx.beginPath();
        ctx.moveTo(pos.x, pos.y);
    }

    function draw(e) {
        if (!isDrawing) return;
        
        // 성능 최적화: 브라우저 주사율에 맞춰 그리기
        requestAnimationFrame(() => {
            if (!isDrawing) return;
            const pos = getPos(e);
            const idx = getGridIndex(pos.x, pos.y);
            
            if (idx !== -1) {
                ctx.beginPath();
                ctx.moveTo(lastPos.x, lastPos.y);
                ctx.lineTo(pos.x, pos.y);
                ctx.stroke();
                
                checkAccuracy(idx, pos.x, pos.y);
                lastPos = pos;
            }
        });
    }

    function checkAccuracy(idx, x, y) {
        const state = gridStates[idx];
        if (state.complete) return;

        const colWidth = canvas.offsetWidth / gridCols;
        const rowHeight = canvas.offsetHeight / gridRows;
        
        // 해당 칸 내부의 상대 좌표 (0~1)
        const relX = (x % colWidth) / colWidth;
        const relY = (y % rowHeight) / rowHeight;

        let updated = false;

        // 모든 획의 포인트를 검사 (획순 무관하게 근처에 오면 인식하도록 개선하여 싱크로율 UP)
        charTemplate.strokes.forEach((stroke, sIdx) => {
            stroke.points.forEach((pt, pIdx) => {
                if (!state.checkpointStatus[sIdx][pIdx]) {
                    const dist = Math.hypot(pt.x - relX, pt.y - relY);
                    if (dist < 0.12) { // 판정 정밀도 (0.1 ~ 0.15 사이가 적당)
                        state.checkpointStatus[sIdx][pIdx] = true;
                        state.pointsReached++;
                        updated = true;
                    }
                }
            });
        });

        if (updated) {
            const acc = Math.round((state.pointsReached / state.totalPoints) * 100);
            info.style.background = `linear-gradient(90deg, #2e86de ${acc}%, rgba(46, 134, 222, 0.9) ${acc}%)`;
            info.innerText = `${idx + 1}번 칸 정확도: ${acc}%`;

            if (acc >= 95) { // 95% 이상이면 완성으로 처리
                state.complete = true;
                info.innerText = `${idx + 1}번 칸 완성! 아주 잘 썼어요! ✨`;
                info.style.background = '#27ae60';
            }
        }
    }

    function resetAll() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        gridStates.forEach(s => {
            s.pointsReached = 0;
            s.complete = false;
            s.checkpointStatus = charTemplate.strokes.map(str => str.points.map(() => false));
        });
        info.innerText = "연습장에 'あ'를 써보세요";
        info.style.background = "rgba(46, 134, 222, 0.95)";
    }

    // 마우스 이벤트
    canvas.addEventListener('mousedown', startDrawing);
    window.addEventListener('mousemove', draw);
    window.addEventListener('mouseup', () => isDrawing = false);

    // 터치 이벤트
    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        startDrawing(e);
    }, {passive: false});
    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        draw(e);
    }, {passive: false});
    canvas.addEventListener('touchend', () => isDrawing = false);

</script>
</body>
</html>