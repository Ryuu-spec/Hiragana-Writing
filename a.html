<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=1200">
<title>ã‚ ì“°ê¸° ì—°ìŠµ ì˜¤ë²„ë ˆì´</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    width: 1200px;
    height: 675px;
    overflow: hidden;
    background: transparent;
    font-family: 'Noto Sans KR', sans-serif;
  }

  /* ì „ì²´ ì»¨í…Œì´ë„ˆ - Genially ìŠ¬ë¼ì´ë“œì™€ ë™ì¼ ì‚¬ì´ì¦ˆ */
  #container {
    position: relative;
    width: 1200px;
    height: 675px;
    background: transparent;
  }

  /* ê²©ì ì˜¤ë²„ë ˆì´ ì˜ì—­ */
  #grid-overlay {
    position: absolute;
    left: 637px;
    top: 143px;
    width: 514px;
    height: 500px;
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    grid-template-rows: repeat(4, 1fr);
    gap: 0;
    background: transparent;
  }

  /* ê° ì…€ */
  .cell {
    position: relative;
    width: 102.8px;
    height: 125px;
    background: transparent;
    cursor: crosshair;
    overflow: hidden;
  }

  /* ì…€ ë‚´ ìº”ë²„ìŠ¤ */
  .cell canvas {
    position: absolute;
    top: 0; left: 0;
    width: 100%;
    height: 100%;
    background: transparent;
  }

  /* íšìˆœ ìƒ‰ê¹” (ã‚ 3íš) */
  /* 1íš: íŒŒë€ìƒ‰, 2íš: ì´ˆë¡ìƒ‰, 3íš: ì£¼í™©ìƒ‰ */

  /* í”¼ë“œë°± íŒì—… */
  #feedback {
    position: absolute;
    top: 100px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(255,255,255,0.95);
    border-radius: 16px;
    padding: 12px 24px;
    font-size: 15px;
    font-weight: 700;
    box-shadow: 0 4px 20px rgba(0,0,0,0.2);
    display: none;
    z-index: 100;
    white-space: nowrap;
    pointer-events: none;
  }

  /* ì»¨íŠ¸ë¡¤ íŒ¨ë„ */
  #controls {
    position: absolute;
    bottom: 8px;
    left: 637px;
    display: flex;
    gap: 8px;
    z-index: 50;
  }

  .ctrl-btn {
    padding: 6px 14px;
    border: none;
    border-radius: 20px;
    font-size: 12px;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.2s;
  }

  .ctrl-btn:hover { opacity: 0.85; transform: translateY(-1px); }

  #btn-clear { background: #ff6b6b; color: white; }
  #btn-check { background: #4ecdc4; color: white; }

  /* íšìˆœ ì¸ë””ì¼€ì´í„° */
  #stroke-indicator {
    position: absolute;
    top: 108px;
    left: 637px;
    display: flex;
    gap: 6px;
    z-index: 50;
  }

  .stroke-dot {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    display: flex; align-items: center; justify-content: center;
    font-size: 12px;
    font-weight: 900;
    color: white;
    opacity: 0.35;
    transition: opacity 0.3s, transform 0.3s;
    border: 2px solid rgba(255,255,255,0.6);
  }

  .stroke-dot.active {
    opacity: 1;
    transform: scale(1.2);
    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
  }

  .stroke-dot.done {
    opacity: 0.9;
  }

  #dot1 { background: #4A90E2; }
  #dot2 { background: #27AE60; }
  #dot3 { background: #E67E22; }

  /* ì…€ í™œì„±í™” í‘œì‹œ */
  .cell.active-cell::after {
    content: '';
    position: absolute;
    inset: 1px;
    border: 2px solid rgba(74, 144, 226, 0.5);
    border-radius: 4px;
    pointer-events: none;
    animation: pulse-border 1s ease infinite;
  }

  @keyframes pulse-border {
    0%, 100% { opacity: 0.5; }
    50% { opacity: 1; }
  }

  /* ì™„ë£Œ íš¨ê³¼ */
  .cell.complete-correct::after {
    content: 'âœ“';
    position: absolute;
    inset: 0;
    display: flex;
    align-items: flex-end;
    justify-content: flex-end;
    padding: 4px;
    font-size: 14px;
    color: #27AE60;
    font-weight: 900;
    border: none;
    animation: none;
    pointer-events: none;
  }

  .cell.complete-wrong::after {
    content: 'â†º';
    position: absolute;
    inset: 0;
    display: flex;
    align-items: flex-end;
    justify-content: flex-end;
    padding: 4px;
    font-size: 14px;
    color: #E74C3C;
    font-weight: 900;
    border: none;
    animation: none;
    pointer-events: none;
  }
</style>
</head>
<body>

<div id="container">

  <!-- íšìˆœ ì¸ë””ì¼€ì´í„° -->
  <div id="stroke-indicator">
    <div class="stroke-dot active" id="dot1">1</div>
    <div class="stroke-dot" id="dot2">2</div>
    <div class="stroke-dot" id="dot3">3</div>
  </div>

  <!-- ê²©ì ì˜¤ë²„ë ˆì´ (5ì—´ Ã— 4í–‰ = 20ì¹¸) -->
  <div id="grid-overlay"></div>

  <!-- í”¼ë“œë°± -->
  <div id="feedback"></div>

  <!-- ì»¨íŠ¸ë¡¤ -->
  <div id="controls">
    <button class="ctrl-btn" id="btn-clear">ğŸ—‘ ì „ì²´ ì§€ìš°ê¸°</button>
    <button class="ctrl-btn" id="btn-check">âœ“ íšìˆœ í™•ì¸</button>
  </div>

</div>

<script>
// ===== ì„¤ì • =====
const CELL_W = 102.8;
const CELL_H = 125;
const COLS = 5;
const ROWS = 4;
const TOTAL_CELLS = COLS * ROWS;

// ã‚ íšìˆœ ì •ì˜ (ì •ê·œí™” ì¢Œí‘œ 0~1, ì…€ ê¸°ì¤€)
// 1íš: ìœ„ìª½ ê°€ë¡œ íš (ì˜¤ë¥¸ìª½ìœ¼ë¡œ)
// 2íš: ì™¼ìª½ ì„¸ë¡œ+êº¾ì„ íš (ìœ„ì—ì„œ ì•„ë˜ë¡œ, ì™¼ìª½ ì»¤ë¸Œ)  
// 3íš: ì˜¤ë¥¸ìª½ í° ì›+ê¼¬ë¦¬ íš

const STROKE_COLORS = ['#4A90E2', '#27AE60', '#E67E22'];
const STROKE_WIDTHS = [3, 3, 3];
const TOTAL_STROKES = 3;

// íšìˆœ ë°©í–¥ ê¸°ì¤€ (ì‹œì‘ì  Y ê¸°ì¤€ ì •ê·œí™”)
// 1íš: y < 0.4 ì‹œì‘, ìˆ˜í‰ ë°©í–¥
// 2íš: y < 0.5 ì‹œì‘, ìˆ˜ì§ ë°©í–¥  
// 3íš: ì–´ë””ì„œë“  ê°€ì¥ ê¸´ íš

// ===== ì…€ ìƒì„± =====
const gridEl = document.getElementById('grid-overlay');
const cells = []; // { el, canvas, ctx, strokes: [{points}], currentStroke, strokeCount, isDrawing }

for (let i = 0; i < TOTAL_CELLS; i++) {
  const cell = document.createElement('div');
  cell.className = 'cell';
  cell.dataset.idx = i;

  const canvas = document.createElement('canvas');
  canvas.width = Math.round(CELL_W);
  canvas.height = Math.round(CELL_H);
  cell.appendChild(canvas);

  gridEl.appendChild(cell);

  const ctx = canvas.getContext('2d');
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';

  cells.push({
    el: cell,
    canvas,
    ctx,
    strokes: [],       // ì™„ì„±ëœ íšë“¤
    currentPoints: [], // í˜„ì¬ ê·¸ë¦¬ëŠ” ì¤‘ì¸ íšì˜ ì ë“¤
    isDrawing: false,
    strokeCount: 0,
    done: false,
  });
}

// ===== í˜„ì¬ í™œì„± ì…€ =====
let activeCellIdx = 0;
setActiveCell(0);

function setActiveCell(idx) {
  cells.forEach((c, i) => {
    c.el.classList.remove('active-cell');
  });
  if (idx < TOTAL_CELLS) {
    activeCellIdx = idx;
    if (!cells[idx].done) {
      cells[idx].el.classList.add('active-cell');
    }
  }
}

// ===== íšìˆœ ì¸ë””ì¼€ì´í„° ì—…ë°ì´íŠ¸ =====
function updateStrokeIndicator(strokeCount) {
  for (let i = 1; i <= TOTAL_STROKES; i++) {
    const dot = document.getElementById(`dot${i}`);
    dot.classList.remove('active', 'done');
    if (i < strokeCount + 1) dot.classList.add('done');
    else if (i === strokeCount + 1) dot.classList.add('active');
  }
}

// ===== í¬ì¸íŠ¸ â†’ ìº”ë²„ìŠ¤ ì¢Œí‘œ =====
function getPos(canvas, e) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  if (e.touches) {
    return {
      x: (e.touches[0].clientX - rect.left) * scaleX,
      y: (e.touches[0].clientY - rect.top) * scaleY,
    };
  }
  return {
    x: (e.clientX - rect.left) * scaleX,
    y: (e.clientY - rect.top) * scaleY,
  };
}

// ===== ìŠ¤ë¬´ë”© ê·¸ë¦¬ê¸° =====
function drawSmooth(ctx, points, color, width) {
  if (points.length < 2) return;
  ctx.strokeStyle = color;
  ctx.lineWidth = width;
  ctx.beginPath();
  ctx.moveTo(points[0].x, points[0].y);
  for (let i = 1; i < points.length - 1; i++) {
    const mx = (points[i].x + points[i+1].x) / 2;
    const my = (points[i].y + points[i+1].y) / 2;
    ctx.quadraticCurveTo(points[i].x, points[i].y, mx, my);
  }
  ctx.lineTo(points[points.length-1].x, points[points.length-1].y);
  ctx.stroke();
}

// ===== ìº”ë²„ìŠ¤ ì „ì²´ ë‹¤ì‹œ ê·¸ë¦¬ê¸° =====
function redrawCell(cellData) {
  const { ctx, strokes, canvas } = cellData;
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  strokes.forEach((s, i) => {
    drawSmooth(ctx, s.points, STROKE_COLORS[i] || '#999', STROKE_WIDTHS[i] || 3);
    // íš ì‹œì‘ì  í‘œì‹œ
    if (s.points.length > 0) {
      ctx.beginPath();
      ctx.arc(s.points[0].x, s.points[0].y, 4, 0, Math.PI * 2);
      ctx.fillStyle = STROKE_COLORS[i] || '#999';
      ctx.fill();
    }
  });
}

// ===== íšìˆœ ë¶„ì„ =====
function analyzeStrokes(strokes) {
  if (strokes.length !== TOTAL_STROKES) return null;

  const cw = CELL_W, ch = CELL_H;

  // ê° íšì˜ íŠ¹ì„± ê³„ì‚°
  const features = strokes.map(s => {
    const pts = s.points;
    if (pts.length < 2) return null;
    const xs = pts.map(p => p.x);
    const ys = pts.map(p => p.y);
    const minX = Math.min(...xs), maxX = Math.max(...xs);
    const minY = Math.min(...ys), maxY = Math.max(...ys);
    const dx = pts[pts.length-1].x - pts[0].x;
    const dy = pts[pts.length-1].y - pts[0].y;
    const len = Math.sqrt(dx*dx + dy*dy);
    const spanX = maxX - minX;
    const spanY = maxY - minY;
    return {
      startX: pts[0].x / cw,
      startY: pts[0].y / ch,
      endX: pts[pts.length-1].x / cw,
      endY: pts[pts.length-1].y / ch,
      spanX: spanX / cw,
      spanY: spanY / ch,
      centerY: ((minY + maxY) / 2) / ch,
      totalLen: len / Math.max(cw, ch),
      isHorizontal: spanX > spanY,
      isVertical: spanY > spanX,
    };
  });

  // ã‚ íšìˆœ ê²€ì‚¬
  // 1íš: ìƒë‹¨ ê°€ë¡œíš (startY < 0.5, spanX > spanY, ì˜¤ë¥¸ìª½ ë°©í–¥)
  // 2íš: ì¤‘ê°„ ì„¸ë¡œ/ì‚¬ì„ íš (startY < 0.6, ìˆ˜ì§ í˜¹ì€ ì™¼ìª½ ì»¤ë¸Œ)
  // 3íš: í•˜ë‹¨ í° ì»¤ë¸Œ (ê°€ì¥ ê¸¸ê±°ë‚˜ ë„“ì€ íš)

  const f0 = features[0], f1 = features[1], f2 = features[2];

  const errors = [];

  // 1íš ê²€ì‚¬: ìƒë‹¨ ê°€ë¡œíš
  if (f0 && f0.startY > 0.55) {
    errors.push('1íšì€ ìœ„ìª½ì—ì„œ ì‹œì‘í•´ì•¼ í•´ìš” (ê°€ë¡œ íš)');
  }
  if (f0 && !f0.isHorizontal && f0.spanX < 0.2) {
    errors.push('1íšì€ ê°€ë¡œ ë°©í–¥ìœ¼ë¡œ ê·¸ì–´ì•¼ í•´ìš”');
  }

  // 2íš ê²€ì‚¬: ì™¼ìª½ ì„¸ë¡œíš
  if (f1 && f1.startY > 0.6) {
    errors.push('2íšì€ ì¤‘ê°„ ìœ„ì—ì„œ ì‹œì‘í•´ì•¼ í•´ìš”');
  }
  if (f1 && f1.startX > 0.7) {
    errors.push('2íšì€ ì™¼ìª½ì—ì„œ ì‹œì‘í•´ì•¼ í•´ìš”');
  }

  // 3íš ê²€ì‚¬: í° ì› íš (ê°€ì¥ ë³µì¡í•œ íš)
  if (f2 && f2.startY > 0.75) {
    errors.push('3íšì€ ë„ˆë¬´ ì•„ë˜ì—ì„œ ì‹œì‘í–ˆì–´ìš”');
  }

  const correct = errors.length === 0;
  return { correct, errors };
}

// ===== í”¼ë“œë°± í‘œì‹œ =====
function showFeedback(msg, color, duration = 2000) {
  const fb = document.getElementById('feedback');
  fb.textContent = msg;
  fb.style.background = color === 'green'
    ? 'rgba(39, 174, 96, 0.95)'
    : color === 'red'
    ? 'rgba(231, 76, 60, 0.95)'
    : 'rgba(255,255,255,0.95)';
  fb.style.color = (color === 'green' || color === 'red') ? 'white' : '#333';
  fb.style.display = 'block';
  setTimeout(() => { fb.style.display = 'none'; }, duration);
}

// ===== ì´ë²¤íŠ¸ ë°”ì¸ë”© =====
cells.forEach((cellData, idx) => {
  const { canvas } = cellData;

  function startDraw(e) {
    e.preventDefault();
    if (cellData.done) return;

    // ì´ ì…€ í™œì„±í™”
    setActiveCell(idx);

    if (cellData.strokeCount >= TOTAL_STROKES) {
      showFeedback('ğŸ”„ ì´ë¯¸ 3íš ëª¨ë‘ ì™„ì„±! ì§€ìš°ê³  ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”', 'white');
      return;
    }

    cellData.isDrawing = true;
    cellData.currentPoints = [getPos(canvas, e)];
  }

  function moveDraw(e) {
    e.preventDefault();
    if (!cellData.isDrawing) return;

    const pt = getPos(canvas, e);
    cellData.currentPoints.push(pt);

    // ì‹¤ì‹œê°„ ê·¸ë¦¬ê¸°
    const ctx = cellData.ctx;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    redrawCell(cellData); // ê¸°ì¡´ íš ë‹¤ì‹œ ê·¸ë¦¬ê¸°
    drawSmooth(ctx, cellData.currentPoints,
      STROKE_COLORS[cellData.strokeCount], STROKE_WIDTHS[cellData.strokeCount]);
  }

  function endDraw(e) {
    e.preventDefault();
    if (!cellData.isDrawing) return;
    cellData.isDrawing = false;

    const pts = cellData.currentPoints;
    if (pts.length < 3) return; // ë„ˆë¬´ ì§§ì€ íš ë¬´ì‹œ

    // íš ì €ì¥
    cellData.strokes.push({ points: pts });
    cellData.strokeCount++;
    cellData.currentPoints = [];

    redrawCell(cellData);
    updateStrokeIndicator(cellData.strokeCount);

    if (cellData.strokeCount === TOTAL_STROKES) {
      // íšìˆœ ë¶„ì„
      setTimeout(() => {
        const result = analyzeStrokes(cellData.strokes);
        if (result) {
          if (result.correct) {
            cellData.el.classList.remove('active-cell');
            cellData.el.classList.add('complete-correct');
            cellData.done = true;
            showFeedback('ğŸ‰ íšìˆœ ì •í™•! ì˜ ì¼ì–´ìš”!', 'green');

            // ë‹¤ìŒ ì…€ë¡œ ìë™ ì´ë™
            const nextIdx = idx + 1;
            if (nextIdx < TOTAL_CELLS) {
              setTimeout(() => setActiveCell(nextIdx), 800);
            }
          } else {
            cellData.el.classList.add('complete-wrong');
            showFeedback('âš ï¸ ' + result.errors[0] + ' ë‹¤ì‹œ ë„ì „í•´ë´ìš”!', 'red', 3000);
          }
        }
      }, 200);
    } else {
      const remaining = TOTAL_STROKES - cellData.strokeCount;
      showFeedback(`${cellData.strokeCount}íš ì™„ë£Œ âœ“ â€” ë‚¨ì€ íš: ${remaining}ê°œ`, 'white', 1200);
    }
  }

  // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸
  canvas.addEventListener('mousedown', startDraw);
  canvas.addEventListener('mousemove', moveDraw);
  canvas.addEventListener('mouseup', endDraw);
  canvas.addEventListener('mouseleave', endDraw);

  // í„°ì¹˜ ì´ë²¤íŠ¸
  canvas.addEventListener('touchstart', startDraw, { passive: false });
  canvas.addEventListener('touchmove', moveDraw, { passive: false });
  canvas.addEventListener('touchend', endDraw, { passive: false });
});

// ===== ì „ì²´ ì§€ìš°ê¸° =====
document.getElementById('btn-clear').addEventListener('click', () => {
  cells.forEach(c => {
    c.strokes = [];
    c.currentPoints = [];
    c.strokeCount = 0;
    c.isDrawing = false;
    c.done = false;
    c.el.classList.remove('complete-correct', 'complete-wrong', 'active-cell');
    c.ctx.clearRect(0, 0, c.canvas.width, c.canvas.height);
  });
  setActiveCell(0);
  updateStrokeIndicator(0);
  showFeedback('ğŸ—‘ ì „ì²´ ì§€ì› ì–´ìš”! ì²˜ìŒë¶€í„° ì‹œì‘í•˜ì„¸ìš”', 'white', 1500);
});

// ===== í˜„ì¬ ì…€ íšìˆœ í™•ì¸ =====
document.getElementById('btn-check').addEventListener('click', () => {
  const cellData = cells[activeCellIdx];
  if (cellData.strokeCount < TOTAL_STROKES) {
    showFeedback(`â³ ì•„ì§ ${cellData.strokeCount}/${TOTAL_STROKES}íšë§Œ ì™„ì„±ëì–´ìš”`, 'white', 1500);
    return;
  }
  const result = analyzeStrokes(cellData.strokes);
  if (result) {
    if (result.correct) {
      showFeedback('âœ… íšìˆœì´ ì •í™•í•´ìš”!', 'green');
    } else {
      showFeedback('âŒ ' + result.errors.join(' / '), 'red', 3000);
    }
  }
});

// ì´ˆê¸° ì¸ë””ì¼€ì´í„°
updateStrokeIndicator(0);
</script>
</body>
</html>
