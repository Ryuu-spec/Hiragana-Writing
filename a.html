<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>히라가나 쓰기 피드백 도구 - 개선판</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f3f4f6;
            overflow: hidden;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .header {
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }

        h1 {
            font-size: 1.5rem;
            color: #1f2937;
        }

        .button-group {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
        }

        button {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 0.5rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.875rem;
        }

        button:disabled {
            background-color: #d1d5db;
            cursor: not-allowed;
            color: #6b7280;
        }

        .btn-feedback {
            background-color: #e5e7eb;
            color: #374151;
        }

        .btn-feedback:hover:not(:disabled) {
            background-color: #d1d5db;
        }

        .btn-feedback.active {
            background-color: #3b82f6;
            color: white;
        }

        .btn-feedback.active:hover {
            background-color: #2563eb;
        }

        .btn-clear-cell {
            background-color: #f97316;
            color: white;
        }

        .btn-clear-cell:hover:not(:disabled) {
            background-color: #ea580c;
        }

        .btn-clear-all {
            background-color: #ef4444;
            color: white;
        }

        .btn-clear-all:hover {
            background-color: #dc2626;
        }

        .btn-undo {
            background-color: #8b5cf6;
            color: white;
        }

        .btn-undo:hover:not(:disabled) {
            background-color: #7c3aed;
        }

        .main-content {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            overflow: auto;
        }

        .canvas-wrapper {
            position: relative;
            display: inline-block;
            line-height: 0;
        }

        .background-image {
            width: 100%;
            height: auto;
            display: block;
            user-select: none;
            -webkit-user-drag: none;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
            touch-action: none;
        }

        .footer {
            background: white;
            border-top: 1px solid #e5e7eb;
            padding: 1rem;
        }

        .footer-content {
            max-width: 64rem;
            margin: 0 auto;
        }

        .footer h2 {
            font-size: 1.125rem;
            margin-bottom: 0.5rem;
            color: #1f2937;
        }

        .footer ul {
            list-style: none;
            font-size: 0.875rem;
            color: #6b7280;
        }

        .footer li {
            margin-bottom: 0.25rem;
        }

        .stroke-color {
            font-weight: bold;
        }

        .stats-panel {
            background: #f9fafb;
            border-radius: 0.5rem;
            padding: 0.75rem;
            margin-top: 0.5rem;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 0.5rem;
        }

        .stat-item {
            background: white;
            padding: 0.5rem;
            border-radius: 0.375rem;
            text-align: center;
        }

        .stat-label {
            font-size: 0.75rem;
            color: #6b7280;
            margin-bottom: 0.25rem;
        }

        .stat-value {
            font-size: 1.25rem;
            font-weight: bold;
            color: #1f2937;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.25rem;
            }

            .header {
                padding: 0.75rem;
            }

            .main-content {
                padding: 1rem;
            }

            button {
                padding: 0.4rem 0.8rem;
                font-size: 0.8rem;
            }

            .stats-panel {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>히라가나 쓰기 피드백 도구</h1>
            <div class="button-group">
                <button id="btnFeedback" class="btn-feedback">피드백 보기</button>
                <button id="btnUndo" class="btn-undo" disabled>실행 취소</button>
                <button id="btnClearCell" class="btn-clear-cell" disabled>선택 칸 지우기</button>
                <button id="btnClearAll" class="btn-clear-all">전체 지우기</button>
            </div>
        </div>

        <div class="main-content">
            <div class="canvas-wrapper" id="canvasWrapper">
                <img 
                    src="/mnt/user-data/uploads/001_00.jpg" 
                    alt="히라가나 워크북"
                    class="background-image"
                    id="backgroundImage"
                    draggable="false"
                >
                <canvas id="drawingCanvas"></canvas>
            </div>
        </div>

        <div class="footer">
            <div class="footer-content">
                <h2>사용 방법</h2>
                <ul>
                    <li>• 오른쪽 4×5 그리드의 칸을 클릭/터치하여 글자를 쓰세요</li>
                    <li>• 각 획은 자동으로 다른 색상으로 표시됩니다</li>
                    <li>• "피드백 보기" 버튼을 눌러 정확도와 획수를 확인하세요</li>
                    <li>• "あ"는 3획으로 이루어진 글자입니다 (왼쪽 곡선 → 오른쪽 세로 → 아래 가로)</li>
                    <li id="strokeColors">• 획순 색상: <span class="stroke-color" style="color: #FF6B6B">1획</span>, <span class="stroke-color" style="color: #4ECDC4">2획</span>, <span class="stroke-color" style="color: #45B7D1">3획</span></li>
                </ul>
                
                <div class="stats-panel" id="statsPanel" style="display: none;">
                    <div class="stat-item">
                        <div class="stat-label">총 획수</div>
                        <div class="stat-value" id="statTotalStrokes">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">평균 정확도</div>
                        <div class="stat-value" id="statAvgAccuracy">0%</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">완성된 칸</div>
                        <div class="stat-value" id="statCompleted">0/20</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">3획 칸</div>
                        <div class="stat-value" id="statPerfect">0</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 상수 정의
        const IMAGE_WIDTH = 2000;
        const IMAGE_HEIGHT = 1125;
        const GRID_START_X = 1070;
        const GRID_START_Y = 339;
        const CELL_SIZE = 163;
        const COLS = 5;
        const ROWS = 4;

        // 획순 색상
        const STROKE_COLORS = [
            '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8',
            '#F7DC6F', '#BB8FCE', '#85C1E2', '#F8B195', '#A8E6CF'
        ];

        // "あ" 글자의 이상적인 획순 (정규화된 좌표, 0~1 범위)
        const IDEAL_STROKES = [
            // 1획: 왼쪽 곡선 (위에서 아래로)
            [
                {x: 0.3, y: 0.2},
                {x: 0.28, y: 0.35},
                {x: 0.25, y: 0.5},
                {x: 0.27, y: 0.65},
                {x: 0.32, y: 0.78}
            ],
            // 2획: 오른쪽 세로 (위에서 아래로)
            [
                {x: 0.7, y: 0.15},
                {x: 0.68, y: 0.35},
                {x: 0.66, y: 0.55},
                {x: 0.65, y: 0.75},
                {x: 0.65, y: 0.85}
            ],
            // 3획: 아래 가로 곡선 (왼쪽에서 오른쪽으로)
            [
                {x: 0.25, y: 0.75},
                {x: 0.4, y: 0.72},
                {x: 0.55, y: 0.7},
                {x: 0.68, y: 0.73},
                {x: 0.78, y: 0.8}
            ]
        ];

        // 상태 변수
        let canvas, ctx;
        let isDrawing = false;
        let strokes = {};
        let currentStroke = [];
        let selectedCell = null;
        let showFeedback = false;
        let history = [];

        // DOM 요소
        const btnFeedback = document.getElementById('btnFeedback');
        const btnUndo = document.getElementById('btnUndo');
        const btnClearCell = document.getElementById('btnClearCell');
        const btnClearAll = document.getElementById('btnClearAll');
        const backgroundImage = document.getElementById('backgroundImage');
        const statsPanel = document.getElementById('statsPanel');

        // 초기화
        function init() {
            canvas = document.getElementById('drawingCanvas');
            ctx = canvas.getContext('2d');

            setupCanvas();
            setupEventListeners();
            
            window.addEventListener('resize', setupCanvas);
        }

        // 캔버스 설정
        function setupCanvas() {
            const wrapper = document.getElementById('canvasWrapper');
            const img = backgroundImage;
            
            const scale = img.clientWidth / IMAGE_WIDTH;
            
            canvas.width = IMAGE_WIDTH;
            canvas.height = IMAGE_HEIGHT;
            canvas.style.width = `${IMAGE_WIDTH * scale}px`;
            canvas.style.height = `${IMAGE_HEIGHT * scale}px`;
            
            redrawCanvas();
        }

        // 이벤트 리스너 설정
        function setupEventListeners() {
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', endDrawing);
            canvas.addEventListener('mouseleave', endDrawing);

            canvas.addEventListener('touchstart', startDrawing);
            canvas.addEventListener('touchmove', draw);
            canvas.addEventListener('touchend', endDrawing);

            btnFeedback.addEventListener('click', toggleFeedback);
            btnUndo.addEventListener('click', undo);
            btnClearCell.addEventListener('click', clearSelectedCell);
            btnClearAll.addEventListener('click', clearAll);

            backgroundImage.addEventListener('load', setupCanvas);
        }

        // 캔버스 좌표 가져오기
        function getCanvasCoords(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        // 셀 좌표 가져오기
        function getCellCoords(cellIndex) {
            const col = cellIndex % COLS;
            const row = Math.floor(cellIndex / COLS);
            return {
                x: GRID_START_X + col * CELL_SIZE,
                y: GRID_START_Y + row * CELL_SIZE,
                width: CELL_SIZE,
                height: CELL_SIZE
            };
        }

        // 좌표에서 셀 인덱스 가져오기
        function getCellFromCoords(x, y) {
            if (x < GRID_START_X || y < GRID_START_Y) return null;

            const col = Math.floor((x - GRID_START_X) / CELL_SIZE);
            const row = Math.floor((y - GRID_START_Y) / CELL_SIZE);

            if (col >= 0 && col < COLS && row >= 0 && row < ROWS) {
                return row * COLS + col;
            }
            return null;
        }

        // 그리기 시작
        function startDrawing(e) {
            e.preventDefault();
            const coords = getCanvasCoords(e);
            const cellIndex = getCellFromCoords(coords.x, coords.y);

            if (cellIndex !== null) {
                selectedCell = cellIndex;
                isDrawing = true;
                currentStroke = [coords];
                btnClearCell.disabled = false;
                redrawCanvas();
            }
        }

        // 그리기
        function draw(e) {
            if (!isDrawing || selectedCell === null) return;
            e.preventDefault();

            const coords = getCanvasCoords(e);
            const cellIndex = getCellFromCoords(coords.x, coords.y);

            if (cellIndex === selectedCell) {
                currentStroke.push(coords);
                redrawCanvas();
            }
        }

        // 그리기 종료
        function endDrawing() {
            if (isDrawing && currentStroke.length > 1) {
                saveToHistory();
                
                if (!strokes[selectedCell]) {
                    strokes[selectedCell] = [];
                }
                strokes[selectedCell].push(currentStroke);
                currentStroke = [];
                
                btnUndo.disabled = false;
                updateStats();
                redrawCanvas();
            }
            isDrawing = false;
        }

        // 히스토리 저장
        function saveToHistory() {
            history.push(JSON.parse(JSON.stringify(strokes)));
            if (history.length > 20) {
                history.shift();
            }
        }

        // 실행 취소
        function undo() {
            if (history.length > 0) {
                strokes = history.pop();
                if (history.length === 0) {
                    btnUndo.disabled = true;
                }
                updateStats();
                redrawCanvas();
            }
        }

        // 캔버스 다시 그리기
        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 선택된 셀 하이라이트
            if (selectedCell !== null) {
                const cell = getCellCoords(selectedCell);
                ctx.fillStyle = 'rgba(255, 200, 0, 0.1)';
                ctx.fillRect(cell.x, cell.y, cell.width, cell.height);
            }

            // 저장된 획들 그리기
            for (const [cellIndex, cellStrokes] of Object.entries(strokes)) {
                cellStrokes.forEach((stroke, strokeIndex) => {
                    ctx.strokeStyle = STROKE_COLORS[strokeIndex % STROKE_COLORS.length];
                    ctx.lineWidth = 4;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';

                    ctx.beginPath();
                    stroke.forEach((point, i) => {
                        if (i === 0) {
                            ctx.moveTo(point.x, point.y);
                        } else {
                            ctx.lineTo(point.x, point.y);
                        }
                    });
                    ctx.stroke();
                });
            }

            // 현재 그리는 획
            if (currentStroke.length > 0) {
                const strokeIndex = (strokes[selectedCell] || []).length;
                ctx.strokeStyle = STROKE_COLORS[strokeIndex % STROKE_COLORS.length];
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                ctx.beginPath();
                currentStroke.forEach((point, i) => {
                    if (i === 0) {
                        ctx.moveTo(point.x, point.y);
                    } else {
                        ctx.lineTo(point.x, point.y);
                    }
                });
                ctx.stroke();
            }

            // 피드백 표시
            if (showFeedback) {
                for (const [cellIndex, cellStrokes] of Object.entries(strokes)) {
                    const cell = getCellCoords(parseInt(cellIndex));
                    const feedback = calculateDetailedFeedback(cellStrokes, cell);

                    // 정확도 표시
                    const accuracyColor = feedback.accuracy > 80 ? '#22c55e' : 
                                        feedback.accuracy > 60 ? '#3b82f6' :
                                        feedback.accuracy > 40 ? '#f59e0b' : '#ef4444';
                    
                    ctx.fillStyle = accuracyColor;
                    ctx.font = 'bold 28px Arial';
                    ctx.fillText(`${feedback.accuracy}%`, cell.x + 10, cell.y + 35);

                    // 획순 표시
                    ctx.fillStyle = '#1f2937';
                    ctx.font = 'bold 20px Arial';
                    const strokeText = cellStrokes.length === 3 ? '✓ 3획' : `${cellStrokes.length}획`;
                    ctx.fillText(strokeText, cell.x + 10, cell.y + 65);

                    // 간단한 피드백 메시지
                    if (feedback.message) {
                        ctx.fillStyle = '#6b7280';
                        ctx.font = '14px Arial';
                        ctx.fillText(feedback.message, cell.x + 10, cell.y + 85);
                    }
                }
            }
        }

        // 정규화된 좌표로 변환 (셀 내 0~1 범위)
        function normalizeStroke(stroke, cell) {
            return stroke.map(point => ({
                x: (point.x - cell.x) / cell.width,
                y: (point.y - cell.y) / cell.height
            }));
        }

        // 획의 방향 계산 (위→아래, 왼→오 등)
        function getStrokeDirection(stroke) {
            if (stroke.length < 2) return null;
            
            const start = stroke[0];
            const end = stroke[stroke.length - 1];
            const dx = end.x - start.x;
            const dy = end.y - start.y;
            
            if (Math.abs(dy) > Math.abs(dx) * 1.5) {
                return dy > 0 ? 'down' : 'up';
            } else if (Math.abs(dx) > Math.abs(dy) * 1.5) {
                return dx > 0 ? 'right' : 'left';
            } else {
                return 'diagonal';
            }
        }

        // 두 획 간의 유사도 계산
        function calculateStrokeSimilarity(userStroke, idealStroke) {
            const userNorm = userStroke;
            const idealNorm = idealStroke;
            
            // 시작점과 끝점 비교
            const startDist = Math.sqrt(
                Math.pow(userNorm[0].x - idealNorm[0].x, 2) + 
                Math.pow(userNorm[0].y - idealNorm[0].y, 2)
            );
            const endDist = Math.sqrt(
                Math.pow(userNorm[userNorm.length-1].x - idealNorm[idealNorm.length-1].x, 2) + 
                Math.pow(userNorm[userNorm.length-1].y - idealNorm[idealNorm.length-1].y, 2)
            );
            
            // 거리 기반 점수 (0~100)
            const startScore = Math.max(0, 100 - startDist * 200);
            const endScore = Math.max(0, 100 - endDist * 200);
            
            return (startScore + endScore) / 2;
        }

        // 상세 피드백 계산
        function calculateDetailedFeedback(cellStrokes, cell) {
            if (!cellStrokes || cellStrokes.length === 0) {
                return { accuracy: 0, message: '글자를 써보세요' };
            }

            const strokeCount = cellStrokes.length;
            let totalScore = 0;
            let message = '';

            // 획수 점수
            if (strokeCount === 3) {
                totalScore += 40;
                message = '완벽!';
            } else if (strokeCount < 3) {
                totalScore += 20;
                message = `획이 부족합니다`;
            } else {
                totalScore += 20;
                message = `획이 많습니다`;
            }

            // 각 획의 정확도 계산
            let strokeScores = [];
            for (let i = 0; i < Math.min(strokeCount, 3); i++) {
                const normalized = normalizeStroke(cellStrokes[i], cell);
                const idealStroke = IDEAL_STROKES[i];
                const similarity = calculateStrokeSimilarity(normalized, idealStroke);
                strokeScores.push(similarity);
            }

            // 획 정확도 평균
            if (strokeScores.length > 0) {
                const avgStrokeScore = strokeScores.reduce((a, b) => a + b, 0) / strokeScores.length;
                totalScore += avgStrokeScore * 0.6;
            }

            const accuracy = Math.round(Math.min(100, totalScore));

            return { accuracy, message };
        }

        // 통계 업데이트
        function updateStats() {
            if (!showFeedback) return;

            const totalCells = Object.keys(strokes).length;
            let totalStrokes = 0;
            let totalAccuracy = 0;
            let perfectCells = 0;

            for (const cellStrokes of Object.values(strokes)) {
                totalStrokes += cellStrokes.length;
                if (cellStrokes.length === 3) perfectCells++;
                
                const cell = getCellCoords(0); // 임시
                const feedback = calculateDetailedFeedback(cellStrokes, cell);
                totalAccuracy += feedback.accuracy;
            }

            document.getElementById('statTotalStrokes').textContent = totalStrokes;
            document.getElementById('statAvgAccuracy').textContent = 
                totalCells > 0 ? Math.round(totalAccuracy / totalCells) + '%' : '0%';
            document.getElementById('statCompleted').textContent = `${totalCells}/20`;
            document.getElementById('statPerfect').textContent = perfectCells;
        }

        // 피드백 토글
        function toggleFeedback() {
            showFeedback = !showFeedback;
            btnFeedback.classList.toggle('active');
            btnFeedback.textContent = showFeedback ? '피드백 숨기기' : '피드백 보기';
            statsPanel.style.display = showFeedback ? 'grid' : 'none';
            updateStats();
            redrawCanvas();
        }

        // 선택된 셀 지우기
        function clearSelectedCell() {
            if (selectedCell !== null) {
                saveToHistory();
                delete strokes[selectedCell];
                btnUndo.disabled = false;
                updateStats();
                redrawCanvas();
            }
        }

        // 전체 지우기
        function clearAll() {
            if (Object.keys(strokes).length > 0) {
                saveToHistory();
                btnUndo.disabled = false;
            }
            strokes = {};
            selectedCell = null;
            showFeedback = false;
            btnFeedback.classList.remove('active');
            btnFeedback.textContent = '피드백 보기';
            btnClearCell.disabled = true;
            statsPanel.style.display = 'none';
            redrawCanvas();
        }

        // 페이지 로드 시 초기화
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>
</html>
