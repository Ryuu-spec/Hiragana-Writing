<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>히라가나 쓰기 피드백 도구</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f3f4f6;
            overflow: hidden;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .header {
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }

        h1 {
            font-size: 1.5rem;
            color: #1f2937;
        }

        .button-group {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
        }

        button {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 0.5rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.875rem;
        }

        button:disabled {
            background-color: #d1d5db;
            cursor: not-allowed;
            color: #6b7280;
        }

        .btn-feedback {
            background-color: #e5e7eb;
            color: #374151;
        }

        .btn-feedback:hover:not(:disabled) {
            background-color: #d1d5db;
        }

        .btn-feedback.active {
            background-color: #3b82f6;
            color: white;
        }

        .btn-feedback.active:hover {
            background-color: #2563eb;
        }

        .btn-clear-cell {
            background-color: #f97316;
            color: white;
        }

        .btn-clear-cell:hover:not(:disabled) {
            background-color: #ea580c;
        }

        .btn-clear-all {
            background-color: #ef4444;
            color: white;
        }

        .btn-clear-all:hover {
            background-color: #dc2626;
        }

        .main-content {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            overflow: auto;
        }

        .canvas-wrapper {
            position: relative;
            display: inline-block;
            line-height: 0;
        }

        .background-image {
            width: 100%;
            height: auto;
            display: block;
            user-select: none;
            -webkit-user-drag: none;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
            touch-action: none;
        }

        .footer {
            background: white;
            border-top: 1px solid #e5e7eb;
            padding: 1rem;
        }

        .footer-content {
            max-width: 64rem;
            margin: 0 auto;
        }

        .footer h2 {
            font-size: 1.125rem;
            margin-bottom: 0.5rem;
            color: #1f2937;
        }

        .footer ul {
            list-style: none;
            font-size: 0.875rem;
            color: #6b7280;
        }

        .footer li {
            margin-bottom: 0.25rem;
        }

        .stroke-color {
            font-weight: bold;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.25rem;
            }

            .header {
                padding: 0.75rem;
            }

            .main-content {
                padding: 1rem;
            }

            button {
                padding: 0.4rem 0.8rem;
                font-size: 0.8rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>히라가나 쓰기 피드백 도구</h1>
            <div class="button-group">
                <button id="btnFeedback" class="btn-feedback">피드백 보기</button>
                <button id="btnClearCell" class="btn-clear-cell" disabled>선택 칸 지우기</button>
                <button id="btnClearAll" class="btn-clear-all">전체 지우기</button>
            </div>
        </div>

        <div class="main-content">
            <div class="canvas-wrapper" id="canvasWrapper">
                <img 
                    src="/mnt/user-data/uploads/001_00.jpg" 
                    alt="히라가나 워크북"
                    class="background-image"
                    id="backgroundImage"
                    draggable="false"
                >
                <canvas id="drawingCanvas"></canvas>
            </div>
        </div>

        <div class="footer">
            <div class="footer-content">
                <h2>사용 방법</h2>
                <ul>
                    <li>• 오른쪽 4×5 그리드의 칸을 클릭/터치하여 글자를 쓰세요</li>
                    <li>• 각 획은 자동으로 다른 색상으로 표시됩니다</li>
                    <li>• "피드백 보기" 버튼을 눌러 정확도와 획수를 확인하세요</li>
                    <li>• "あ"는 3획으로 이루어진 글자입니다</li>
                    <li id="strokeColors">• 획순 색상: <span class="stroke-color" style="color: #FF6B6B">1획</span>, <span class="stroke-color" style="color: #4ECDC4">2획</span>, <span class="stroke-color" style="color: #45B7D1">3획</span></li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // 상수 정의
        const IMAGE_WIDTH = 2000;
        const IMAGE_HEIGHT = 1125;
        const GRID_START_X = 1070;
        const GRID_START_Y = 339;
        const CELL_SIZE = 163;
        const COLS = 5;
        const ROWS = 4;

        // 획순 색상
        const STROKE_COLORS = [
            '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8',
            '#F7DC6F', '#BB8FCE', '#85C1E2', '#F8B195', '#A8E6CF'
        ];

        // 상태 변수
        let canvas, ctx;
        let isDrawing = false;
        let strokes = {};
        let currentStroke = [];
        let selectedCell = null;
        let showFeedback = false;

        // DOM 요소
        const btnFeedback = document.getElementById('btnFeedback');
        const btnClearCell = document.getElementById('btnClearCell');
        const btnClearAll = document.getElementById('btnClearAll');
        const backgroundImage = document.getElementById('backgroundImage');

        // 초기화
        function init() {
            canvas = document.getElementById('drawingCanvas');
            ctx = canvas.getContext('2d');

            setupCanvas();
            setupEventListeners();
            
            window.addEventListener('resize', setupCanvas);
        }

        // 캔버스 설정
        function setupCanvas() {
            const wrapper = document.getElementById('canvasWrapper');
            const img = backgroundImage;
            
            // 이미지가 로드된 후에 캔버스 크기 설정
            const scale = img.clientWidth / IMAGE_WIDTH;
            
            canvas.width = IMAGE_WIDTH;
            canvas.height = IMAGE_HEIGHT;
            canvas.style.width = `${IMAGE_WIDTH * scale}px`;
            canvas.style.height = `${IMAGE_HEIGHT * scale}px`;
            
            redrawCanvas();
        }

        // 이벤트 리스너 설정
        function setupEventListeners() {
            // 마우스 이벤트
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', endDrawing);
            canvas.addEventListener('mouseleave', endDrawing);

            // 터치 이벤트
            canvas.addEventListener('touchstart', startDrawing);
            canvas.addEventListener('touchmove', draw);
            canvas.addEventListener('touchend', endDrawing);

            // 버튼 이벤트
            btnFeedback.addEventListener('click', toggleFeedback);
            btnClearCell.addEventListener('click', clearSelectedCell);
            btnClearAll.addEventListener('click', clearAll);

            // 이미지 로드 이벤트
            backgroundImage.addEventListener('load', setupCanvas);
        }

        // 캔버스 좌표 가져오기
        function getCanvasCoords(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        // 셀 좌표 가져오기
        function getCellCoords(cellIndex) {
            const col = cellIndex % COLS;
            const row = Math.floor(cellIndex / COLS);
            return {
                x: GRID_START_X + col * CELL_SIZE,
                y: GRID_START_Y + row * CELL_SIZE,
                width: CELL_SIZE,
                height: CELL_SIZE
            };
        }

        // 좌표에서 셀 인덱스 가져오기
        function getCellFromCoords(x, y) {
            if (x < GRID_START_X || y < GRID_START_Y) return null;

            const col = Math.floor((x - GRID_START_X) / CELL_SIZE);
            const row = Math.floor((y - GRID_START_Y) / CELL_SIZE);

            if (col >= 0 && col < COLS && row >= 0 && row < ROWS) {
                return row * COLS + col;
            }
            return null;
        }

        // 그리기 시작
        function startDrawing(e) {
            e.preventDefault();
            const coords = getCanvasCoords(e);
            const cellIndex = getCellFromCoords(coords.x, coords.y);

            if (cellIndex !== null) {
                selectedCell = cellIndex;
                isDrawing = true;
                currentStroke = [coords];
                btnClearCell.disabled = false;
                redrawCanvas();
            }
        }

        // 그리기
        function draw(e) {
            if (!isDrawing || selectedCell === null) return;
            e.preventDefault();

            const coords = getCanvasCoords(e);
            const cellIndex = getCellFromCoords(coords.x, coords.y);

            // 같은 셀 내에서만 그리기
            if (cellIndex === selectedCell) {
                currentStroke.push(coords);
                redrawCanvas();
            }
        }

        // 그리기 종료
        function endDrawing() {
            if (isDrawing && currentStroke.length > 0) {
                if (!strokes[selectedCell]) {
                    strokes[selectedCell] = [];
                }
                strokes[selectedCell].push(currentStroke);
                currentStroke = [];
                redrawCanvas();
            }
            isDrawing = false;
        }

        // 캔버스 다시 그리기
        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 선택된 셀 하이라이트
            if (selectedCell !== null) {
                const cell = getCellCoords(selectedCell);
                ctx.fillStyle = 'rgba(255, 200, 0, 0.1)';
                ctx.fillRect(cell.x, cell.y, cell.width, cell.height);
            }

            // 저장된 획들 그리기
            for (const [cellIndex, cellStrokes] of Object.entries(strokes)) {
                cellStrokes.forEach((stroke, strokeIndex) => {
                    ctx.strokeStyle = STROKE_COLORS[strokeIndex % STROKE_COLORS.length];
                    ctx.lineWidth = 4;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';

                    ctx.beginPath();
                    stroke.forEach((point, i) => {
                        if (i === 0) {
                            ctx.moveTo(point.x, point.y);
                        } else {
                            ctx.lineTo(point.x, point.y);
                        }
                    });
                    ctx.stroke();
                });
            }

            // 현재 그리는 획
            if (currentStroke.length > 0) {
                const strokeIndex = (strokes[selectedCell] || []).length;
                ctx.strokeStyle = STROKE_COLORS[strokeIndex % STROKE_COLORS.length];
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                ctx.beginPath();
                currentStroke.forEach((point, i) => {
                    if (i === 0) {
                        ctx.moveTo(point.x, point.y);
                    } else {
                        ctx.lineTo(point.x, point.y);
                    }
                });
                ctx.stroke();
            }

            // 피드백 표시
            if (showFeedback) {
                for (const [cellIndex, cellStrokes] of Object.entries(strokes)) {
                    const cell = getCellCoords(parseInt(cellIndex));
                    const accuracy = calculateAccuracy(cellStrokes, cell);

                    // 정확도 표시
                    ctx.fillStyle = accuracy > 70 ? '#4CAF50' : accuracy > 40 ? '#FF9800' : '#F44336';
                    ctx.font = 'bold 24px Arial';
                    ctx.fillText(`${accuracy}%`, cell.x + 10, cell.y + 30);

                    // 획순 표시
                    ctx.fillStyle = '#333';
                    ctx.font = '18px Arial';
                    ctx.fillText(`${cellStrokes.length}획`, cell.x + 10, cell.y + 55);
                }
            }
        }

        // 정확도 계산
        function calculateAccuracy(cellStrokes, cell) {
            if (!cellStrokes || cellStrokes.length === 0) return 0;

            // 획수가 3개면 보너스
            const strokeCountBonus = cellStrokes.length === 3 ? 30 : 0;

            // 기본 점수
            const baseScore = Math.min(100, 40 + strokeCountBonus + cellStrokes.length * 10);

            return Math.min(100, baseScore);
        }

        // 피드백 토글
        function toggleFeedback() {
            showFeedback = !showFeedback;
            btnFeedback.classList.toggle('active');
            btnFeedback.textContent = showFeedback ? '피드백 숨기기' : '피드백 보기';
            redrawCanvas();
        }

        // 선택된 셀 지우기
        function clearSelectedCell() {
            if (selectedCell !== null) {
                delete strokes[selectedCell];
                redrawCanvas();
            }
        }

        // 전체 지우기
        function clearAll() {
            strokes = {};
            selectedCell = null;
            showFeedback = false;
            btnFeedback.classList.remove('active');
            btnFeedback.textContent = '피드백 보기';
            btnClearCell.disabled = true;
            redrawCanvas();
        }

        // 페이지 로드 시 초기화
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>
</html>
